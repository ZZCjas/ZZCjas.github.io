# 洛谷P1956(NOI导刊) Sum vs Deepseek R1

## 题目描述

给出一个数列  $a_1,a_2,\cdots,a_n$ 和  $k,p$；

设  $S_{i,j}=\sum\limits_{k=i}^ja_k$，则：
 $$\mathit{Answer}=\min\{S_{i,j}\bmod p\ |\ S_{i,j}\bmod p\ge k\}$$
其中， $i\le j, \{S_{i,j}\bmod p\ |\ S_{i,j}\bmod p\ge k\}\ne\varnothing$。

## 输入格式

第一行三个正整数  $n,k,p$。

第二行  $n$ 个正整数，表示  $a_1,a_2,\cdots,a_n$。

## 输出格式

一行一个正整数，表示  $\mathit{Answer}$。

## 输入输出样例 #1

### 输入 #1

```
7 2 17
12
13
15
11
16
26
11
```

### 输出 #1

```
2
```

## 说明/提示

### 数据范围

对于 $100\%$ 的数据， $1\le n\le10^5$，$1\le k,p,a_i\le10^{18}$。

####ZZC提示:这是一道数学味很浓的oi题,包含了数论、集合和同余的相关知识

---

##Deepseek的思考过程

哦，这道题看起来有点挑战性。我得仔细读题目。题目要求我们找到一个子数组的和模p后的结果，这个结果必须大于等于k，然后在这些符合条件的模值中找出最小的那个。如果没有这样的子数组，那题目保证集合非空，所以不用考虑这种情况。
那首先，我得想怎么计算所有可能的S_{i,j} mod p，并且找到满足条件的最小值。但是n的范围是1e5，显然不能暴力枚举所有可能的子数组，因为这样的时间复杂度会是O(n^2)，肯定会超时。那必须找到一个更高效的方法。
那我们需要找到一个数学上的方法或者某种数据结构来优化这个过程。这里可能需要前缀和的一些性质，或者模运算的性质。
首先，想到前缀和。设前缀和数组为sum，其中sum[0]=0，sum[i] = a1 + ... + ai。那么S_{i,j} = sum[j] - sum[i-1]。所以模p的话，就是（sum[j] - sum[i-1]） mod p。我们的目标是找到这样的i和j，使得这个模值 >=k，然后在这些中找最小的。
那模的结果等于（sum[j] - sum[i-1]）%p。要这个结果>=k。我们需要找到对于每个j，找到某个i-1的前缀和，使得sum[j] - sum[i-1]的差模p后的结果>=k，并且尽可能小。
这可能涉及到对每个j，寻找i-1的前缀和满足某种条件，从而得到最小的（sum[j] - sum[i-1]） mod p >=k的情况。
这时候，我们可以将问题转化为：对于每个j，我们想找到某个i的前缀和sum[i]，使得sum[j] - sum[i]的模p的值>=k，并且尽可能小。因为i可以是0到j-1之间的任意位置。
那如何高效地找到这样的sum[i]呢？这里可能需要维护一个有序的数据结构，比如平衡二叉搜索树，来保存之前的前缀和的值。然后对于当前的sum[j]，我们可以在这个结构中查找符合条件的sum[i]。
具体来说，对于当前的sum[j]，我们想要sum[j] - sum[i] mod p >=k。那么这可以转化为两种情况：
sum[j] - sum[i] >=k mod p的情况可能比较复杂。或者，我们可以将模运算展开。sum[j] - sum[i] = m*p + r，其中r是模的结果，且0 <= r <p。我们需要r >=k。所以sum[j] - sum[i] ≡ r mod p，且r >=k。这等价于sum[j] - sum[i] >=k 或者 sum[j] - sum[i] <= -(p -k) （因为当sum[j] - sum[i]是负数时，模p的结果会是p + (sum[j]-sum[i])，这时候可能满足r >=k）。
或者，可能更直接的方法是考虑sum[j] mod p的值。假设sum[j] mod p = s_j。那么sum[i] mod p = s_i。那么sum[j] - sum[i] mod p等于（s_j - s_i） mod p。这等于s_j - s_i如果s_j >=s_i，否则是s_j -s_i +p。所以我们要的是这个结果>=k。
比如，当s_j >=s_i时，s_j -s_i >=k。或者当s_j <s_i时，s_j -s_i +p >=k。这时候两种情况都要满足。
那么，我们的问题转化为：对于每个j，我们需要找到之前的某个i的前缀和的模值s_i，使得：
如果s_j >= s_i +k → s_i <= s_j -k → 此时的结果是s_j -s_i >=k，模p的结果就是s_j -s_i，这时候要取最小的这个值，即尽可能大的s_i <=s_j -k。
或者，当s_i >s_j时，那么模的结果是s_j -s_i +p >=k → s_j -s_i +p >=k → s_i <=s_j +p -k。这时候，s_i >s_j的情况下，s_j +p -k >=s_i。因为s_i的取值范围是[0,p)，所以此时s_i的取值范围是(s_j, min(p, s_j +p -k))]。这时候，模的结果是s_j -s_i +p。我们希望这个值尽可能小，也就是尽可能大的s_i（因为s_j -s_i +p随着s_i的增大而减小）。
所以，对于每个j，我们需要考虑两种情况：
1. 是否存在s_i <= s_j -k。如果存在，则最大的这样的s_i可以使得s_j -s_i尽可能大，这样结果s_j -s_i的值可能更小吗？或者说，最大的s_i会使得差值更小？比如，假设s_j是10，k是3。那么s_i可以最大到7。此时差是3，刚好满足>=k。或者，比如s_j是5，k是3，那么s_i要<=2。此时最大的s_i是2，差是3。所以在这种情况下，最大的s_i会得到最小的可能的结果，即刚好等于k。所以这种情况下，对于情况1，我们需要找到最大的s_i <= s_j -k，这样结果就是s_j -s_i，这会是情况1中的最小可能值。
2. 是否存在s_i >s_j，并且s_i <=s_j +p -k。这时，s_j -s_i +p >=k。我们希望s_i尽可能大，这样s_j -s_i +p的值就会尽可能小。例如，当s_j=0，p=17，k=2。s_i必须满足0 +17 -k=15 >=s_i>0。s_i的最大可能值是15。此时结果是0-15+17=2，刚好等于k的最小可能值。所以，在情况2中，我们需要找到最大的s_i <=s_j +p -k，并且s_i >s_j。这样结果就是s_j -s_i +p，此时的值等于(s_j +p -s_i) -k +k ? 不太清楚。或者更直接地说，当s_i尽可能大时，s_j -s_i +p的值就越小。例如，假设s_j +p -k >=s_i，那么最大的s_i满足s_i <=s_j +p -k且s_i>s_j，那么此时s_i是min(s_j +p -k, p-1)，并且大于s_j。例如，如果s_j=5，p=17，k=2。那么s_j +p -k =5+17-2=20。这个大于p，所以取p-1。但此时，s_i必须>5。所以符合条件的s_i范围是（5，20）mod p。因为p是17，所以20 mod17是3，所以范围是（5,3）？这可能有问题。哦，原式中的s_i是模p后的结果，所以s_j +p -k可能大于p吗？比如，假设s_j是15，p=17，k=2。那么s_j +p -k=15+17-2=30。30 mod17是13。所以此时的条件是s_i <=13，并且s_i>15。但是这在模17的情况下，s_i的取值范围是大于15的（比如16），同时还要<=13。这显然不可能。所以这种情况可能不存在。
所以，或许在情况2中，只有当s_j +p -k >=p时，也就是当s_j >=k的时候，可能无法满足这种情况？或者可能我需要重新分析情况。
这个时候可能需要重新考虑两种情况的条件。
或许正确的条件应该是：
当s_j >=k，那么情况1存在可能的s_i，使得s_i <= s_j -k。此时可以找到最大的这样的s_i，这样得到的差值是s_j -s_i >=k，且尽可能小（因为差值等于k的时候是可能的）。
当s_j <k，那么情况1的条件s_i <=s_j -k不可能满足，因为s_j -k会是负数，而s_i >=0。所以此时必须考虑情况2，即是否存在s_i >s_j，且s_i <=s_j +p -k。这时候，模的结果是s_j -s_i +p >=k。这时候，s_i的取值范围是(s_j, s_j +p -k]。但因为s_i的取值范围在模p之后是0到p-1，所以当s_j +p -k >=p时，也就是当s_j >=k时，这个区间可能包含多个部分？
或者，可能我应该将条件重新写成：
要满足（s_j -s_i） mod p >=k。这等价于两种情况中的一种：
- s_j -s_i >=k → s_i <=s_j -k → 此时模的结果是s_j -s_i，必须>=k且尽可能小。这个时候最大的s_i对应的差值最小。
或者：
- s_j -s_i <0 →此时模的结果是s_j -s_i +p >=k → s_i >s_j → s_j -s_i +p >=k → s_i <=s_j +p -k →同时s_i >s_j。
所以对于情况2，s_i的取值范围是 s_j <s_i <=s_j +p -k。但是因为s_i的取值范围是0到p-1，所以当s_j +p -k >=p时，即当s_j >=k时，此时s_j +p -k >=p → s_i <=s_j +p -k mod p？这可能不太对。或者更直接地说，s_j +p -k可能超过p，这时候在模p的意义下，s_j +p -k相当于s_j -k。例如，假设s_j +p -k =s_j -k +p。比如，当s_j=5，p=17，k=10。则s_j +p -k =5+17-10=12。所以此时s_i的取值范围是大于5且小于等于12。这些s_i的值在0-16之间是有效的。这样情况下，如果存在这样的s_i，那么模的结果是5 -s_i +17 >=10 →22 -s_i >=10 →s_i <=12。同时s_i>5。所以s_i的范围是6到12。这时候，当s_i取12时，结果是5-12+17=10，刚好满足条件。这时候结果就是10，等于k的最小可能值。
所以，在这种情况下，对于情况2，我们需要找到最大的s_i满足 s_j <s_i <=s_j +p -k。此时的结果是s_j -s_i +p，等于(s_j +p -s_i)。为了使这个结果尽可能小，我们需要s_i尽可能大。因此，在情况2中，最大的s_i即为最优解。
综上，对于每个j，我们需要在之前的所有s_i中找到两种情况中的可能，并取最小值。
那么，对于每个j，我们可以分两种情况来处理：
情况1：寻找最大的s_i <=s_j -k。如果存在这样的s_i，则候选值为s_j -s_i。
情况2：寻找最大的s_i <=s_j +p -k，并且s_i>s_j。如果存在这样的s_i，则候选值为s_j -s_i +p。
然后，我们需要在所有候选值中选择最小的那个，作为当前j的最优解，然后全局取所有j的最优解的最小值。
现在的问题是如何高效地维护s_i的集合，并能够快速查询这两种情况下的最大值。
考虑到n是1e5，每个元素都需要O(logn)的时间处理，所以总的时间复杂度是O(n logn)，这应该是可以接受的。
所以，我们需要维护一个有序的结构，例如C++中的set或者multiset，其中保存了之前的s_i的值。对于每个j，我们计算s_j的前缀和模p后的值，然后在set中查询两种情况的可能最大值。
具体来说：
对于当前s_j，我们首先处理情况1：找到最大的s_i <=s_j -k。这可以通过set的upper_bound函数找到第一个大于s_j -k的元素的前一个元素。或者，可以用lower_bound来找到第一个不小于s_j -k +1的元素，然后减一。
例如，假设set中有元素按升序排列。我们想要找最大的s_i <=x，其中x是s_j -k。可以用auto it = set.upper_bound(x); 如果it不是begin，那么最大的符合条件的元素是*--it。
如果找到这样的元素，那么候选值为s_j - *it。
然后处理情况2：找到最大的s_i满足 s_j <s_i <=s_j +p -k。这可以分解为两个条件：s_i>s_j，并且s_i <=s_j +p -k。
但是s_j +p -k可能超过p吗？比如，当s_j=15，p=17，k=3，那么s_j +p -k=15+17-3=29。这时候，在模p的意义下，s_i的范围是s_j+1到29 mod17=12。这相当于s_i的取值范围是0到12，或者s_j+1到p-1，加上0到12？这可能需要更仔细的分析。
或者，因为s_i是模p后的值，所以s_j +p -k可能大于等于p。例如，s_j=15，k=3，p=17。那么s_j +p -k=15+17-3=29。29 mod17=12。所以此时s_i的取值范围是大于15，并且<=12。这在模17的情况下，这相当于s_i的取值范围是16或者0到12。所以这时候，s_i的条件是s_i>15或者<=12。这可能比较复杂。
或者，我们可以将情况2的条件转换为s_i <= s_j +p -k，并且s_i>s_j。这时候，由于s_i是模p后的结果，所以当s_j +p -k >=p时，这相当于s_i <= (s_j +p -k) mod p，并且s_i>s_j。这可能只有在s_j <k的情况下才能成立。例如，当s_j <k时，s_j +p -k =p +s_j -k >=p -k +0 >=p可能吗？比如，当p=17，k=15，s_j=0，则s_j +p -k=0+17-15=2。这时候条件s_i>0且<=2。此时符合条件的s_i可以是1或2。
或者，可能我需要将情况2的条件视为在模p下的范围。这时候，s_i的范围是（s_j, s_j +p -k] mod p。例如，当s_j +p -k >=p，那么这个区间会分成两部分：s_j <s_i <=p-1，以及0 <=s_i <= (s_j +p -k) mod p。这时候，这两个区间的合并可能形成一个环形区域。这种情况下，如何高效地找到最大的s_i？
这个时候，可能需要将情况2的条件转换为在环上的范围。比如，当s_j +p -k >=p时，条件s_i <=s_j +p -k等价于s_i <= (s_j +p -k) mod p。而s_j +p -k mod p等于s_j -k mod p。例如，当s_j=15，p=17，k=3，则s_j +p -k=29 mod17=12。所以条件变为s_i>15且<=12。这显然不可能，所以在这种情况下情况2没有解。或者，这可能意味着在模p的环上，区间是从s_j+1到s_j +p -k mod p。这时候，当s_j +p -k >=p时，这个区间实际上是环状的：从s_j+1到p-1，以及从0到(s_j +p -k) mod p。例如，s_j=15，p=17，k=3，那么s_j +p -k=29 mod17=12。所以条件为s_i>15且<=12。这在模17的情况下，相当于s_i在16到12之间，这实际上是s_i=16，0,1,...,12。所以在这种情况下，s_i的取值范围是s_i属于(15,12] mod17，也就是s_i=16,0,1,…,12。
此时，最大的s_i在环上的区间中最大的那个。例如，在这种情况下，最大的s_i是12吗？或者可能最大的是p-1吗？
或者，当区间是环状的，比如从a到b，其中a >b，那么在环上最大的元素是p-1，或者最大的元素在区间中最大的元素是p-1？
这个时候，要找到最大的s_i，这可能比较复杂。比如，假设情况是s_i需要属于（s_j, s_j +p -k] mod p。这可能有环状的区间。那么，我们需要找到在这个区间内的最大可能的s_i。
这个时候，可以将问题拆分为两种情况：
如果 s_j +p -k >=p：
那么，区间是 (s_j, p-1] ∪ [0, (s_j +p -k) mod p]。这时候，最大的元素可能是max(p-1, (s_j +p -k) mod p)。所以在这种情况下，最大的s_i是p-1，或者在右边的区间中找到最大的。例如，当右边的区间是0到x，那么最大的x就是最大的。
否则，当s_j +p -k <p，那么区间是(s_j, s_j +p -k]。这时候，最大的s_i是s_j +p -k。
所以，这可能比较复杂，需要分情况处理。
或者，是否可以将条件转化为 s_i mod p ∈ (s_j, s_j +p -k] mod p。在这种情况下，最大的s_i是在这个区间中的最大值。这可能等于s_j +p -k，或者在环状的情况下等于p-1或者某个值。
这可能很难处理，所以是否有另一种方法？
或许，我们可以将条件转换为 s_i ≡ x mod p，其中x的取值范围是(s_j, s_j +p -k] mod p。然后，最大的x在模p中的值可能等于s_j +p -k -1吗？或者，最大的可能值？
或者，我们可以将s_i视为一个数值，在模p的意义下，s_i的取值范围是0到p-1。那么，当我们要找s_i满足s_i >s_j，并且s_i <=s_j +p -k，那么这可能有两种情况：
情况A：s_j +p -k <=p-1。此时，s_i的取值范围是(s_j, s_j +p -k]。这种情况下最大的s_i是s_j +p -k.
情况B：s_j +p -k >p-1。此时，s_i的取值范围是(s_j, p-1]和[0, s_j +p -k -p]。等价于，s_j +p -k -p = s_j -k。所以，此时s_i的取值范围是(s_j, p-1]和[0, s_j -k]。那么，最大的s_i是max(p-1, s_j -k)。因为s_j -k可能比p-1小吗？例如，当s_j=15，p=17，k=3，则s_j -k=12 <16=p-1。所以最大的s_i是p-1=16.
综上，对于情况2的最大s_i的寻找，可以分为两种情况：
当s_j +p -k <=p-1 →最大是s_j +p -k.
否则，最大是p-1或者s_j -k中的较大者。但s_j -k可能为负数？比如，如果s_j=0，k=5，p=17。那么s_j +p -k=0+17-5=12<=16，所以这属于情况A。此时最大是12。哦，那这种情况A的条件是s_j +p -k <=p-1 →即 s_j -k <=-1 →k >=s_j +1. 所以当k>s_j时，情况A的条件成立？或者等式变换：
s_j +p -k <=p-1 →s_j -k <=-1 →k >=s_j +1.
所以当k >=s_j +1时，情况A的条件成立。否则，情况B的条件成立。
例如，当k >=s_j +1时，情况A成立，此时s_j +p -k >=p ?
抱歉，可能我刚才的等式变换有错误。正确的推导应该是：
s_j +p -k <= p-1 → p -k <= p-1 -s_j → -k <= -1 -s_j → k >=s_j +1.
是的。所以当k >=s_j+1时，s_j +p -k <=p-1。此时，s_j +p -k的取值范围是 [s_j+1, p-1 + (s_j+1 -k)]？或者这个可能要看具体情况。
不管怎样，此时的条件是s_j +p -k <=p-1 →即 s_j -k <=-1 →k >=s_j +1.
在这种情况下，情况A成立，那么s_i的取值范围是（s_j, s_j +p -k]。最大的s_i是s_j +p -k。比如，当s_j=3，k=5，p=17。s_j +p -k=3+17-5=15，<=16。所以此时s_i的取值范围是（3,15]，最大是15。
而当k <s_j+1时，即k <=s_j，那么情况B成立。此时s_j +p -k >=p → s_j +p -k =p + (s_j -k) →所以模p后的值是s_j -k。但此时，s_i的取值范围是（s_j, p-1]和[0, s_j -k]。此时最大的s_i是p-1或者s_j -k。比如，当s_j=15，p=17，k=3。此时情况B成立，s_j -k=12。此时，s_i的取值范围是（15,16]和[0,12]。最大的s_i是16或12。显然最大的s_i是16，即p-1。
所以，在情况B中，最大的s_i是p-1，只要存在这样的s_i。
但是如何高效地在set中找到这种情况下的最大值呢？
或许，可以将情况2的条件分为两个部分：
当s_j +p -k >=p时：
我们需要找到最大的s_i满足s_i >s_j或者s_i <=s_j +p -k mod p。这相当于在环状区间中的最大值。这可能比较复杂。
或者，我们可以将条件转换为：
在模p的情况下，s_i属于（s_j， s_j +p -k] mod p。此时，最大的s_i是这个区间中的最大值。
例如，当区间是（s_j, s_j +p -k]，当s_j +p -k >=p时，区间实际上是（s_j, p-1]和[0, s_j +p -k -p]。而s_j +p -k -p = s_j -k。所以区间是（s_j, p-1]和[0, s_j -k]。此时最大的s_i是p-1，或者s_j -k中的较大者。但是s_j -k可能比p-1小吗？
例如，当s_j=15，k=3，p=17。s_j -k=12，小于p-1=16。所以最大的s_i是16。当s_j=5，k=3，p=17。s_j +p -k=5+17-3=19 mod17=2。所以区间是（5,2]。在模17的情况下，这相当于s_i>5或者s_i<=2。所以最大的s_i是16（p-1）或者2？例如，假设set中有16，则16>5，并且属于区间的一部分。所以此时最大的s_i是16。或者，如果set中最大的元素是2，那么这属于区间的右边部分，取最大的那个。
这似乎很难处理。在这种情况下，如何高效地找到最大的s_i？
或许，可以将问题分为两种情况：
当s_j +p -k >=p →也就是当k <=s_j +p -k mod p？或者当k <=s_j？
或者，可以尝试找到最大的s_i，满足s_i >s_j或者s_i <=s_j +p -k mod p。这时候最大的s_i可能是整个set中的最大值，或者某个特定的值。
或者，可以认为，在环状的情况下，最大的s_i是set中的最大值，或者set中最大的元素是否在区间内。例如，如果set中的最大值是p-1，并且p-1>s_j，那么这一定属于情况2的区间。或者，如果set中的最大值属于（s_j，s_j +p -k mod p]的区间？
这可能比较复杂，但或许我们可以分两步查找：
首先，在set中查找最大的元素是否属于情况2的区间。如果是，则取这个最大值。否则，查找是否在右边的区间中有元素。
或者，可以将条件分成两个部分：
1. 在set中查找最大的元素是否满足s_i >s_j。如果有，那么取最大的这样的s_i，并且同时s_i <=s_j +p -k mod p。这可能吗？
或者，这可能要分情况处理：
当s_j +p -k >=p时，即s_j -k >=0：
此时，条件2的区间是（s_j, p-1] ∪ [0, s_j -k]. 最大的可能s_i是p-1（如果存在的话）或者最大的在0到s_j -k中的元素。
当s_j +p -k <p时，即s_j -k <0:
此时，条件2的区间是（s_j, s_j +p -k], 因为s_j +p -k <p。因此，最大的s_i是s_j +p -k（如果存在的话）。
所以，为了处理情况2，可以：
如果 k <=s_j：
那么，情况B的条件成立，此时条件2的区间是（s_j, p-1]和[0, s_j -k]。此时最大的s_i是p-1（如果存在的话），或者在0到s_j -k之间的最大值。
否则（k>s_j）：
情况A的条件成立，此时条件2的区间是（s_j, s_j +p -k]. 最大的s_i是s_j +p -k，如果存在的话。
所以，处理情况2时，可以分为两种情况：
当k <=s_j：
此时，最大的s_i可以是两种情况中的最大值：
a. 最大的s_i在（s_j, p-1]。也就是在set中是否存在元素>s_j？如果有的话，最大的这样的元素。
b. 最大的s_i在[0, s_j -k]。也就是在set中的最大元素是否<=s_j -k？如果有的话，最大的这样的元素。
所以，我们需要在这两个区间中取最大值。
或者，这可能比较复杂。例如，假设当前s_j=15，p=17，k=3。此时条件2的区间是（15,16]（即s_i=16）和[0,12]。此时最大的s_i是16（如果存在的话）或者12（如果存在的话）。
所以在这种情况下，我们需要在set中查找最大的元素是否在（s_j, p-1]区间，或者在[0, s_j -k]区间。
这可能分两步：
首先，在set中查找是否有元素>s_j。如果有，那么最大的这样的元素是候选1。
然后，在set中查找是否有元素<=s_j -k。如果有，最大的这样的元素是候选2。
然后，比较候选1和候选2，取较大的那个作为情况2的候选。
或者，这可能不正确，因为候选1可能不满足条件2的区间。例如，当s_j=15，s_j -k=12，所以候选2必须<=12。而候选1是最大的元素>15，比如16。则此时候选1满足条件，候选2满足条件。但我们需要将这两个中的最大值进行比较，取最大的那个。
这样，当候选1存在，比如16，则候选1是最大的，所以情况2的候选值为s_j -16 +p →15-16+17=16。这可能大于k的条件吗？
哦，此时k=3。所以，情况2的条件是模后的结果>=k。这个时候，结果必须>=3。例如，候选1的模结果是15-16+17=16，>=3。候选2的模结果是15-12=3，也>=3。所以在这种情况下，取最大的s_i（16或12）对应的结果更小吗？
当候选1是16时，结果16；候选2是12时，结果3。显然取3更优。所以这说明，在情况2中，最大的s_i可能不是最优的。比如，在候选1和候选2之间，应该选择哪一个？
哦，这似乎有问题。这说明，在情况2中，最大的s_i可能对应的结果不是最小的。例如，当候选1对应的结果是16，而候选2对应的结果是3时，显然候选2更优。这时候，如果取最大的s_i可能无法得到最小的结果。
这表明，我的之前的思路有错误。原来的思路是，在情况2中，s_i越大，结果越小。这似乎并不正确？
比如，在情况2中，结果等于s_j -s_i +p。所以，当s_i越大，结果越小。比如，假设s_j=15，s_i=16，结果是15-16+17=16。而如果s_i=12，结果是15-12=3。哦，这显然不符合情况。因为此时情况2的条件是当s_i>s_j时，或者当s_i属于条件2的区间吗？
或者，我可能混淆了情况1和情况2的条件。
哦，情况2的条件是：当s_j <s_i <=s_j +p -k。此时，模的结果是s_j -s_i +p。这结果必须>=k。
而在这个例子中，s_j=15，k=3，p=17。条件2的区间是（15,16]和[0,12]。所以s_i可以是16或者12。当s_i=16时，结果是15-16+17=16 >=3。当s_i=12时，条件是s_i <=15+17-3=29 mod17=12。但此时s_i=12 <=12，但s_i=12是否大于s_j=15？ 不，12<15。所以，这似乎不符合情况2的条件。那这说明，当k<=s_j时，情况2的区间是（s_j, p-1]和[0, s_j -k]。那s_i必须同时满足s_i>s_j或者s_i <=s_j -k吗？
或者，这可能表明我的条件分析有错误。这时候，我需要重新审视条件。
回到条件分析：
情况2的条件是：
当s_i>s_j时，并且s_j -s_i +p >=k →s_i <=s_j +p -k →这可以重新排列为s_i <=s_j +p -k。因为s_i>s_j，所以必须满足s_j <s_i <=s_j +p -k.
在这种情况下，s_j +p -k可能大于或等于p。例如，当s_j=15，k=3，p=17，那么s_j +p -k=15+17-3=29。此时s_i <=29 mod p=12。所以在这种情况下，s_i的取值范围是s_j <s_i <=12。这在模p的情况下，意味着s_i可以是16（s_j=15，s_i=16>15，且16 <=12吗？不，16>12，所以这种情况下，s_i的取值只能是s_j+1到p-1（即16）吗？
或者，这说明当s_j +p -k >=p时，即s_j >=k，此时s_i的条件是s_j <s_i <=s_j +p -k →但因为s_j +p -k >=p，所以模p后的s_j +p -k等于s_j -k。例如，s_j=15，k=3，那么s_j +p -k=15+17-3=29 mod17=12。所以s_i的取值范围是>15，并且<=12。这在模17的情况下，这显然是不可能的。所以当s_j >=k时，情况2的条件无法满足。所以在这种情况下，情况2的条件没有解？
这可能吗？比如，当s_j >=k时，是否只有情况1有可能的解？
例如，假设s_j=5，p=17，k=3。此时情况1的条件是s_i <=5-3=2。此时可能存在s_i=2，此时差值是3，满足条件。而情况2的条件是s_i>5，且s_i <=5+17-3=19 mod17=2。所以s_i的取值范围是>5且<=2。这在模17的情况下，s_i只能是6,7,...,16，但是必须<=2，这显然不可能。所以当s_j >=k时，情况2的条件没有解。
哦，原来如此！这似乎是一个关键点。这可能意味着，当s_j >=k时，情况2的条件s_i>s_j且s_i <=s_j +p -k在模p的情况下没有解。因为s_j >=k，所以s_j +p -k = s_j -k +p。这个值模p后等于s_j -k。所以，当s_j >=k时，s_j +p -k modp = s_j -k >=0。此时，s_j >=k →s_j -k >=0 →s_j +p -k >=p →模p后的值为s_j -k。此时，情况2的条件是s_i>s_j（即s_i>=s_j+1 modp？或者原数的比较？）并且s_i <=s_j -k。但因为s_j >=k →s_j -k >=0。所以，当s_j >=k时，s_j -k >=0。此时，s_i>s_j的条件意味着s_i>s_j >=k >=0。而s_i <=s_j -k。但s_j >=k →s_j -k >=0。所以，当s_j >=k时，s_i>s_j的条件和s_i <=s_j -k的条件只能同时满足如果s_j -k >=s_j+1，这显然不可能。例如，s_j=5，k=3 →s_j -k=2。此时s_i必须>5且<=2 →不可能。因此，当s_j >=k时，情况2的条件没有解。只有情况1可能有解。
哦，这似乎是一个重要的结论。这说明，当s_j >=k时，情况2的条件不可能满足。所以在这种情况下，只需要考虑情况1的可能解。而情况2的条件只有在s_j <k时才可能有解。
这个结论是否正确？
是的。因为当s_j >=k时，情况2的条件是s_i>s_j，并且s_i <=s_j +p -k →s_i <=s_j -k modp →当s_j >=k时，s_j -k >=0。所以，s_i必须满足s_j <s_i <=s_j -k。但s_j -k <=s_j -0 =s_j →而s_i>s_j的条件和s_i <=s_j -k的条件矛盾。因此，当s_j >=k时，情况2的条件无法满足。所以此时，只有当s_j <k时，才需要考虑情况2的可能。
这大大简化了问题！
因此，总结：
对于每个j，当前s_j是sum[j] mod p的值。
处理两种情况：
1. 情况1：寻找最大的s_i <=s_j -k。如果存在这样的s_i，则候选值为s_j -s_i。这候选值>=k，因为s_i <=s_j -k →s_j -s_i >=k。此时，当s_j >=k时，可能存在解；当s_j <k时，s_j -k是负数，所以s_i必须<=负数，但s_i >=0，所以情况1没有解。
2. 情况2：只有当s_j <k时，才需要考虑。此时，s_i>s_j，并且s_i <=s_j +p -k。这时候，模的结果是s_j -s_i +p >=k。此时，s_i的取值范围是s_j <s_i <=s_j +p -k。因为s_j <k，所以s_j +p -k =p +s_j -k。因为 s_j <k →p +s_j -k >p -k +0 →可能大于等于p吗？例如，当p=17，s_j=2，k=3 →s_j +p -k=2+17-3=16。此时s_i的取值范围是3到16。这满足s_i>s_j的条件，并且s_i <=16，所以符合条件的s_i有很多。
这个时候，我们需要找到最大的s_i满足s_j <s_i <=s_j +p -k。这时候，最大的s_i是s_j +p -k，或者set中最大的元素不超过这个值。
因为s_j +p -k可能大于p-1吗？例如，当s_j=5，k=3，p=17。那么s_j +p -k=5+17-3=19 mod17=2。此时s_j <k（5<3？不，5>3。哦，这例子不适用）。所以，当s_j <k时，s_j +p -k =p +s_j -k。这可能超过p吗？
比如，当p=17，s_j=0，k=3 →s_j +p -k=0+17-3=14。这没有超过p-1=16。此时，s_i的取值范围是0 <s_i <=14。最大的s_i是14.
当p=17，s_j=15，k=20 →s_j=15 <k=20 →s_j +p -k=15+17-20=12. 此时s_i的取值范围是15 <s_i <=12 →这在模p下，相当于s_i=16,0,1,...,12。这时候，最大的s_i是16吗？或者12？
这个时候，情况2的条件是s_i>15，并且<=12。这在模17的情况下，s_i的取值只能是16，或者0到12。此时最大的s_i是16。此时，结果等于15-16+17=16 mod17=16，是否>=k=20？显然16<20，所以这不符合条件。这说明我的条件分析有错误？
哦，这说明当s_j <k时，情况2的条件是否成立？
这个时候，情况2的条件是：s_j -s_i +p >=k →s_i <=s_j +p -k。此时，s_i必须满足s_j <s_i <=s_j +p -k。而因为s_j <k →s_j +p -k = p +s_j -k. 因为s_j <k →s_j -k是负数，所以p +s_j -k等于p - (k -s_j)。这可能大于或小于p？
例如，当s_j=15，k=20，p=17 →s_j +p -k=15+17-20=12. 此时s_i必须>15（即16）且<=12。这显然不可能。所以此时情况2的条件无法满足？
那这说明，当s_j +p -k <p时，情况2的条件是否有可能满足？
比如，当s_j=0，k=3，p=17 →s_j +p -k=0+17-3=14. 此时s_i的取值范围是0 <s_i <=14. 所以，如果存在s_i=14，那么结果是0-14+17=3 >=k=3 →符合条件。所以这种情况下情况2的条件成立。
所以，当s_j <k时，情况2的条件是否成立取决于是否s_j +p -k >=s_j +1？或者说，当s_j +p -k >=s_j +1？
或者，当s_j +p -k >=s_j +1时，即 p -k >=1 →k <=p-1。这总是成立的，因为k的范围是1<=k <=p（根据输入描述中的情况，k和p都是正整数，可能k可以等于p吗？根据题目中的条件，输入的k可以是<=p吗？比如，如果k=p，那么要求模后的结果>=p是不可能的，因为模后的结果只能是0到p-1。但题目中的条件保证集合非空，所以k必须<=p-1。所以，当k=p时，模后的结果>=k的情况只能是模后的结果等于p，这不可能。所以题目中的k的输入必须<=p-1。或者题目中的条件可能允许k<=p？比如，当k=p时，答案只能是0？需要看题目中的条件。
根据题目描述，输入中的k和p可以是任何正整数。当k>=p时，模后的结果>=k的条件无法满足，因为模后的结果最大是p-1。但题目中的条件保证集合非空，所以在这种情况下输入数据中的k必须<=p-1。或者题目中的输入保证这一点。所以，在程序中可能不需要处理k>=p的情况，因为题目保证集合非空。因此，在情况2中，当s_j <k时，s_j +p -k >=s_j +1 →因为 p -k >=1 →k <=p-1。此时，s_j +p -k = (p -k) +s_j >=s_j +1 →p -k >=1 →k <=p-1。因此，在这种情况下，s_j +p -k >=s_j +1 →s_j +p -k >=s_j +1 →即 s_j <k <=p-1 →是的，因为k <=p-1，所以p -k >=1。所以，当s_j <k时，s_j +p -k >=s_j +1 →因此，s_i的取值范围是s_j +1 <=s_i <=s_j +p -k.
例如，当s_j=0，k=3，p=17 →s_j +p -k=14。此时s_i的取值范围是1~14。所以，如果存在s_i=14，则候选值为0-14+17=3 >=k=3。符合条件。
当s_j=15，k=20，p=17 →这可能不可能，因为k=20>p=17。此时题目中的输入可能不会出现这种情况，因为集合可能为空。但题目中的条件保证集合非空。所以，这种情况可能不存在于输入数据中。
综上，当s_j <k时，情况2的条件是否满足，取决于是否存在s_i在(s_j, s_j +p -k]的范围内。而s_j +p -k可能超过p-1吗？
例如，当s_j=5，k=3，p=10。此时s_j <k吗？5<3？不。所以这例子不适用。另一个例子：s_j=2，k=5，p=10。s_j <k →是的。s_j +p -k=2+10-5=7。这没有超过p-1=9。此时s_i的取值范围是3~7。如果存在s_i=7，则候选值为2-7+10=5 >=5，符合条件。
所以在这种情况下，当s_j <k时，s_j +p -k的值等于p +s_j -k，这可能大于或等于p吗？例如，s_j=0，k=1，p=5 →s_j +p -k=0+5-1=4 <5-1=4。所以此时s_i的取值范围是1~4。符合条件。
所以，当s_j <k时，s_j +p -k等于p +s_j -k。因为k <=p-1（因为题目保证集合非空），所以p +s_j -k >=p +0 - (p-1) =1。但s_j +p -k的值是否超过p？
例如，s_j=3，k=4，p=5 →s_j +p -k=3+5-4=4 <p=5。所以s_i的取值范围是4>3且<=4 →s_i=4.
如果k=0，可能吗？题目中的输入k可能为0吗？根据输入描述，k是正整数。所以k>=1。所以，当s_j <k时，k>=1。所以，s_j +p -k >=s_j +1 →因为 p >=k -s_j +s_j +1 →p >=k +1? 不，不一定。例如，当p=5，k=3，s_j=0 →s_j +p -k=0+5-3=2 >=0+1=1 →是的。此时s_i的取值范围是1~2.
综上，当s_j <k时，情况2的条件中的s_j +p -k可能大于等于p吗？例如，当s_j=5，k=3，p=17 →s_j +p -k=5+17-3=19. 19 mod17=2. 此时，s_i的取值范围是s_j <s_i <=2 →即s_i>5且<=2。这在模17的情况下，相当于s_i的取值范围是6~16，或者0~2。此时，最大的s_i是16或者2。例如，假设set中有16，则s_i=16>5，且16 <=2？不，这显然不可能。这说明在这种情况下，情况2的条件没有解？
这可能说明，当s_j +p -k >=p时，情况2的条件无法满足，因为此时s_j +p -k modp等于s_j -k，而s_j <k →s_j -k是负数 →s_j +p -k modp等于s_j +p -k →比如，当s_j=5，k=3，p=10 →s_j +p -k=5+10-3=12 mod10=2 →s_j <k吗？5<3？不，所以这例子不适用。当s_j=2，k=5，p=10 →s_j +p -k=2+10-5=7 →s_j=2<k=5 →条件成立。此时s_i的取值范围是3~7。所以，当s_j +p -k <=p-1时，情况2的条件是成立的。而当s_j +p -k >=p时，即s_j +p -k >=p →s_j >=k →这与s_j <k的条件矛盾。因此，当s_j <k时，s_j +p -k =s_j +p -k. 因为p >=k（因为题目保证集合非空，所以k<=p-1，所以p>=k+1-？不确定），所以s_j +p -k >=s_j +1。此时，s_i的取值范围是s_j+1 <=s_i <=s_j +p -k。此时，这个区间的右端点s_j +p -k可能超过p-1吗？
例如，假设p=10，k=7，s_j=3 →s_j <k →是的。s_j +p -k=3+10-7=6 <p-1=9。所以s_i的取值范围是4~6.
另一个例子：p=10，k=3，s_j=8 →s_j <k？8<3？不。所以这例子不适用。
再一个例子：p=10，k=5，s_j=2 →s_j <k →是的。s_j +p -k=2+10-5=7 <=9。所以s_i的取值范围是3~7.
哦，是的，所以在这种情况下，s_j +p -k的值不会超过p-1。因为当s_j <k时，s_j can be up to k-1. 所以，s_j +p -k <= (k-1)+p -k =p-1.
所以，当s_j <k时，s_j +p -k的值必定 <=p-1。因此，情况2的条件中的s_i的取值范围是(s_j, s_j +p -k]，这区间中的元素在0到p-1之间。因此，情况2的条件中的s_i的取值范围是连续的，从s_j+1到s_j +p -k。
这结论对吗？
例如，当s_j=0，k=5，p=10 →s_j +p -k=0+10-5=5. 所以s_i的取值范围是1~5.
当s_j=3，k=5，p=10 →s_j +p -k=3+10-5=8. s_i的取值范围是4~8.
是的，这都在0~9的范围内。所以，当s_j <k时，s_j +p -k的值等于 s_j +p -k，且因为k<=p-1，所以 p >=k+1. 所以，s_j +p -k >=s_j +1 →s_j +p -k >=s_j +1.
因此，当s_j <k时，情况2的条件中的s_i的取值范围是一个连续的区间，即s_j+1到s_j +p -k。这区间中的元素都在0到p-1的范围内。因此，在这种情况下，我们可以使用set中的upper_bound和lower_bound函数来查找最大的s_i <=s_j +p -k，并且s_i>s_j.
所以，处理情况2的方法是：
在set中查找最大的s_i，满足s_i <=s_j +p -k，并且s_i>s_j.
这可以分解为：查找最大的s_i <=s_j +p -k，并且s_i>s_j.
这相当于在set中找到最大的元素在区间（s_j, s_j +p -k]。
为了高效地找到这个元素，可以这样做：
在set中，找到第一个大于s_j +p -k的元素。如果存在这样的元素，那么最大的符合条件的元素是该元素的前一个元素，前提是它大于s_j。否则，可能没有这样的元素。
或者，更直接的方式：
在set中，所有元素是排序好的。我们可以找到最大的元素x，满足x>s_j且x <=s_j +p -k.
这可以通过查找set中大于s_j的最小元素，然后找到在<=s_j +p -k的元素中的最大值。
或者，可以用lower_bound找到第一个大于s_j的元素，然后在这个位置开始，找到最大的不超过s_j +p -k的元素。
例如：
在set中，所有元素是排序好的。我们想要找到最大的元素x，满足x>s_j且x <=s_j +p -k.
步骤：
1. 使用lower_bound找到第一个大于s_j的元素的位置it.
2. 然后，在it到end()之间，找到最大的元素<=s_j +p -k.
这可以通过upper_bound(s_j +p -k)的前一个元素。
或者，可以使用upper_bound来找到第一个大于s_j +p -k的元素，然后该元素的前一个元素就是最大的符合条件的元素。
例如：
```cpp
auto it_start = s.lower_bound(s_j + 1); // 第一个大于s_j的元素.
auto it_end = s.upper_bound(s_j +p -k);
然后，在[it_start, it_end)的范围内找到最大的元素。如果该范围为空，则没有解。否则，最大的元素是*prev(it_end).
或者，可以合并这些步骤：
auto it = s.upper_bound(s_j +p -k);
if (it != s.begin()) {
--it;
if (*it > s_j) {
// 找到符合条件的元素
} else {
// 没有找到
}
}
或者，这可能不行，因为有可能it所指向的元素不大于s_j。所以，正确的方式应该是：
首先，找到最大的元素<=s_j +p -k。然后，判断该元素是否>s_j.
这可能更简单。
例如：
auto it = s.upper_bound(s_j +p -k);
if (it != s.begin()) {
--it;
if (*it > s_j) {
// 这是一个候选解
candidate = *it;
} else {
// 没有候选解
}
}
```
这样，我们找到了最大的元素<=s_j +p -k，然后检查是否>s_j.
如果是的话，那么这就是情况2的候选解。
否则，情况2无解。
综上，处理情况2的步骤为：
当s_j <k时：
1. 计算target =s_j +p -k.
2. 在set中查找最大的元素<=target，并且>s_j.
3. 如果存在这样的元素，候选值为s_j -该元素 +p.
否则，情况2无解。
综上，对于每个j的处理步骤如下：
1. 计算当前s_j = (sum_prev + a_j) mod p.
其中，sum_prev是前j-1项的前缀和模p。
2. 初始化候选解为无穷大。
3. 处理情况1：
a. 如果 s_j >=k:
在set中查找最大的元素<=s_j -k.
如果存在，候选值为s_j -该元素。这一定>=k.
更新候选解.
b. 否则:
情况1无解.
4. 处理情况2:
a. 如果 s_j <k:
计算 target = s_j +p -k.
在set中查找最大的元素<=target，并且>s_j.
如果存在，候选值为s_j -该元素 +p. 这需要>=k.
更新候选解.
5. 将当前s_j插入set中。
6. 维护全局的最小候选解.
现在的问题是，如何高效地实现步骤3和4中的查找。
对于情况1，当s_j >=k时：
我们查找最大的元素<=s_j -k.
这可以通过使用set的upper_bound函数。
例如：
```cpp
auto it = s.upper_bound(s_j -k);
if (it != s.begin()) {
--it;
candidate1 = s_j - *it;
if (candidate1 >=k) {
// 有效，更新答案.
}
}
```
但这时，s_j - *it >=k吗？因为*it <=s_j -k →s_j - *it >=k →是的。所以 candidate1必然>=k.
所以，情况1的候选值肯定有效。
对于情况2，当s_j <k时：
计算target =s_j +p -k.
查找最大的元素<=target且>s_j.
这可以通过：
```cpp
auto it = s.upper_bound(target);
if (it != s.begin()) {
--it;
if (*it > s_j) {
candidate2 = (s_j - *it + p) % p;
// 该值等于s_j - *it +p, 因为s_j <*it →s_j -*it是负数，所以模p等于加上p.
// 此时，candidate2 = s_j - *it + p.
// 这个值必须>=k.
// 因为根据情况2的条件，*it <=target →*it <=s_j +p -k →s_j +p -k >=*it →p -k >=*it -s_j →k <=s_j +p - *it → s_j - *it +p >=k.
// 所以 candidate2 >=k.
// 因此，候选值有效.
}
}
```
是的，因为情况2的条件是*it <=s_j +p -k →s_j +p -k - *it >=0 → p -k >= *it - s_j →k <=p +s_j - *it → s_j - *it +p >=k.
所以，候选值必然>=k.
综上，可以保证候选值有效。
最后，全局维护最小的候选值即可。
现在，如何维护sum_prev？
sum_prev是前j-1项的前缀和模p的值。初始时为0.
对于每个j，sum_prev = (sum_prev + a_j) % p.
然后，将sum_prev插入到set中，并在处理完j的候选解后插入。因为处理j的候选解时，使用的是之前的前缀和。
例如，初始时，set中包含0（sum[0] mod p）。
处理j=1时，计算sum_prev = a1 mod p，然后计算候选解，然后插入sum_prev到set中。或者在处理j=1的候选解时，set中包含sum[0] mod p=0。然后，在处理完候选解后，将sum_prev插入到set中。
这需要注意，在处理j时，sum_prev是sum[j] mod p的值，而set中包含的是sum[0], sum[1],...,sum[j-1} mod p的值。例如，处理j时，sum_prev是sum[j] mod p，而处理j的候选解时，使用set中的元素（即sum[0]~sum[j-1} mod p）来进行查询。处理完候选解后，将sum[j] mod p插入到set中，供后续的j+1使用。
所以，初始化sum_prev为0，并将0插入到set中。然后，对于每个j from 1 to n:
sum_prev = (sum_prev + a_j) % p.
然后，处理当前sum_prev的候选解，查询set中的元素（此时set中的元素是sum[0]~sum[j-1} mod p）.
处理完候选解后，将sum_prev插入到set中。
例如，初始时，set={0}。处理j=1时，sum_prev是a_1 mod p。在处理时，查询set中的元素（即0），计算候选解。之后，将sum_prev插入到set中，此时set={0, sum_prev}。
这样，每次处理j时，set中的元素是前j-1个前缀和的模p值，而当前的sum_prev是第j个前缀和的模p值。
综上，代码的大致结构如下：
```cpp
初始化：
set<int> s;
s.insert(0);
int sum_prev =0;
int answer = INF;
对于每个j in 1..n:
a_j = ... 输入的第j个数.
sum_prev = (sum_prev + a_j) % p;
// 处理当前sum_prev的候选解.
if (sum_prev >=k):
auto it = s.upper_bound(sum_prev -k);
if (it != s.begin()){
--it;
candidate1 = sum_prev - *it;
if (candidate1 >=k) {
answer = min(answer, candidate1);
}
}
else:
// 情况1无效.
// 处理情况2:
if (sum_prev <k):
target = sum_prev + p -k;
auto it = s.upper_bound(target);
if (it != s.begin()) {
--it;
if (*it > sum_prev) {
candidate2 = (sum_prev - *it + p);
if (candidate2 >=k) {
answer = min(answer, candidate2);
}
}
}
// 将sum_prev插入到set中.
s.insert(sum_prev);
```
循环结束后，输出answer.
需要注意的是，sum_prev的范围可能非常大，因为a_i和p可以是1e18，所以需要处理大数问题。但是在C++中，set的模板参数是long long，可以处理大数。
此外，sum_prev的计算需要取模，这可能会遇到溢出问题。因为a_j和p可以是1e18，所以每次相加时sum_prev可能会溢出，所以需要使用取模的方式防止溢出。例如，每次更新sum_prev时：
sum_prev = (sum_prev + a_j) % p;
但是，在C++中，如果sum_prev的类型是long long，那么即使a_j是1e18，相加后的结果可能超过LLONG_MAX，导致溢出。所以，这需要小心处理。例如，可以使用模运算的性质，将加法分解为多次取模。
例如，sum_prev = (sum_prev % p + a_j % p) % p;
这可能更安全，因为sum_prev已经是模p的结果，所以sum_prev%p等于sum_prev。所以可以写成：
sum_prev = (sum_prev + a_j) % p;
因为sum_prev和a_j的模p的结果相加可能超过p，所以需要再次取模。
综上，代码的大致框架已经明确。现在需要考虑如何处理数据范围和可能的溢出情况。
例如，对于输入中的a_i，应该使用long long类型。sum_prev的类型应该是long long，因为p可以是1e18。
在C++中，set的底层实现是有序的，可以快速进行插入和查询。每个查询的时间复杂度是O(logn)，其中n是set中的元素数量，即j的个数。总的时间复杂度是O(n logn)，对于n=1e5来说，是可以接受的。
测试样例：
输入样例1：
7 2 17
12
13
15
11
16
26
11
前缀和模17：
sum[0] =0.
sum[1]=12 mod17=12.
sum[2]=12+13=25 mod17=8.
sum[3]=8+15=23 mod17=6.
sum[4]=6+11=17 mod17=0.
sum[5]=0+16=16 mod17=16.
sum[6]=16+26=42 mod17=42-2*17=8.
sum[7]=8+11=19 mod17=2.
处理每个j时的sum_prev：
j=1: sum_prev=12.
此时，set中的元素是0.
情况1: sum_prev=12 >=k=2 →需要找最大的s_i <=12-2=10.
set中的元素是0，符合条件。候选值为12-0=12. 此时answer=12.
情况2：sum_prev=12 >=2 →无需处理。
插入12到set.
j=2: sum_prev=8.
情况1: 8 >=2 →找最大的s_i <=8-2=6. set中的元素是0,12. 最大的<=6的是0. 候选值8-0=8. 此时answer=8.
情况2: 无需处理.
插入8到set.
j=3: sum_prev=6.
情况1: 6>=2 →找最大的s_i <=6-2=4. set中的元素是0,8,12. 最大的<=4的是0.候选值6-0=6. answer=6.
插入6到set.
j=4: sum_prev=0.
情况1: 0 >=2 →不成立. 无需处理.
情况2: sum_prev=0 <2. 所以需要处理.
target=0 +17 -2=15.
在set中找最大的s_i <=15且>0.
set中的元素是0,6,8,12.
最大的符合条件的元素是12. candidate2=0-12 +17=5. 5>=2 →answer=5.
插入0到set.
j=5: sum_prev=16.
情况1:16 >=2 →找最大的s_i <=14.
set中的元素是0,6,8,12,0. 排序后是0,0,6,8,12.
最大的<=14的是12. 候选值16-12=4. answer=4.
插入16到set.
j=6: sum_prev=8.
情况1:8>=2 →找最大的s_i <=6.
set中的元素是0,0,6,8,12,16. 最大的<=6是6.候选值8-6=2. answer=2.
插入8到set.
j=7: sum_prev=2.
情况1:2>=2 →找最大的s_i <=0.
set中的元素是0,0,6,8,8,12,16. 最大的<=0的是0. 候选值2-0=2. answer还是2.
插入2到set.
最终，答案是2.
与样例的输出一致。这说明思路是正确的。
综上，现在需要将这一思路转化为代码。
在C++中，需要注意以下几点：
- 使用long long类型存储所有变量。
- set的插入和查询操作。
- 处理前缀和模p的计算，避免溢出。
代码的结构大致如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main() {
ll n, k, p;
cin >> n >> k >> p;
vector<ll> a(n);
for (auto &x : a) {
cin >> x;
}
set<ll> s;
s.insert(0);
ll sum_prev = 0;
ll answer = LLONG_MAX;
for (int i = 0; i < n; ++i) {
sum_prev = (sum_prev + a[i]) % p;
// 处理情况1：sum_prev >=k
if (sum_prev >= k) {
ll target = sum_prev - k;
auto it = s.upper_bound(target);
if (it != s.begin()) {
--it;
ll candidate = sum_prev - *it;
answer = min(answer, candidate);
}
} else {
// 处理情况2：sum_prev <k
ll target = sum_prev + p - k;
auto it = s.upper_bound(target);
if (it != s.begin()) {
--it;
if (*it > sum_prev) {
ll candidate = (sum_prev - *it + p);
answer = min(answer, candidate);
}
}
}
s.insert(sum_prev);
}
cout << answer << endl;
}
}
```
但这是否正确？
需要处理一些细节，比如，当sum_prev <k时，情况2的target可能超过p？例如，当sum_prev=0，k=3，p=10，那么target=0+10-3=7. 在set中查找<=7且>0的元素。
比如，如果set中有5，那么候选值是0-5+10=5 >=3 →符合条件。
在代码中，处理情况2时，计算target = sum_prev + p -k。然后查找最大的s_i <=target且>sum_prev.
这可以通过在set中使用upper_bound(target),然后--it，并检查是否大于sum_prev.
例如：
it = s.upper_bound(target) →第一个大于target的元素的位置.
如果it != s.begin(), 则--it，此时*it <=target.
然后检查*it >sum_prev.
如果满足条件，则计算候选值。
例如，当sum_prev=0，k=3，p=10，target=7. 在set中有5和7.
当处理到sum_prev=0时，情况2的条件成立。查找最大的元素<=7且>0.
在set中，假设元素是5，7.
upper_bound(7)是end(),所以--it指向7. 7>0，候选值为0-7+10=3. 3 >=3，符合条件。 answer被更新为3.
这与预期相符。
综上，代码是正确的。

------

##Deepseek给出的代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    ll n, k, p;
    cin >> n >> k >> p;
    vector<ll> a(n);
    for (auto &x : a) cin >> x;

    set<ll> prefix_mod = {0};
    ll sum_mod = 0, ans = LLONG_MAX;

    for (auto &num : a) {
        sum_mod = (sum_mod + num) % p;

        // Case 1: sum_mod >= k
        if (sum_mod >= k) {
            auto it = prefix_mod.upper_bound(sum_mod - k);
            if (it != prefix_mod.begin()) {
                it--;
                ans = min(ans, sum_mod - *it);
            }
        } else { // Case 2: sum_mod < k
            ll target = sum_mod + p - k;
            auto it = prefix_mod.upper_bound(target);
            if (it != prefix_mod.begin()) {
                it--;
                if (*it > sum_mod) {
                    ans = min(ans, sum_mod - *it + p);
                }
            }
        }

        prefix_mod.insert(sum_mod);
    }

    cout << ans << endl;

    return 0;
}
```
##提交结果
![Deepseek的实力](https://cdn.luogu.com.cn/upload/image_hosting/kphyrjrv.png)

#这就是DeepSeek R1的代码和数学实力!!!!!