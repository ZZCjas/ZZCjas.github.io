很久很久以前

算法突然出现

带来导论

带走了AC又消失不见

编程十分危险

世间谁最勇敢

一位懵逼儿赶来

大声喊

我要

建出最高的树

打出最大的表

搜进最深的递归

把AC带回到面前

老师非常高兴

忙问他的学识

年轻人想了想

他说

老师我会

深搜广搜DP倍增贪心和暴力

再来一次

深搜广搜DP倍增贪心和暴力

是不是

深搜广搜DP倍增贪心和暴力

对对是

深搜广搜DP倍增贪心和暴力

懵逼无名少年

捧着算法导论

带着大家的希望

从学校里出发

战胜BUG来袭

获得GDB神器

无数代码见证

他慢慢升级

偏远OJ角落

AC所有题目

一路排序

伴随指引前路的线段树

进入决赛考场

比赛和可怕难题

少年打开IDE

难题道

我是

Floyd区间DP二分红黑树

再来一次

Floyd区间DP二分红黑树

是不是

Kruskal三维DP二叉排序树

不对是

Floyd区间DP二分红黑树

于是

深搜广搜DP倍增贪心和暴力

打出

康托展开模拟枚举单源最短路

应用

拓扑排序Trie结构Polya定律

套入

Dijkasta联通分量BellmanFord

最后

深搜广搜DP倍增贪心和暴力

他使用了

IO优化树链剖分输出随机数

调用了

矩阵速幂虚二叉树行列式消元

完成了

凸包扫描后缀数组网络最大流

老师听说

深搜广搜DP倍增贪心和暴力

他忘了写

#include<cstdio>与freopen

就让深搜广搜DP倍增贪心和暴力

全手写map/set稳定版本KMP实现

啦啦

懵逼少年

敲着键盘

Ctrl+V来几遍

他发明了一个算法

也在天天渐渐复杂

为了避免以后麻烦

算法叫做

"*&%1&2)64^…!@"

它的全名十分难念

我不想说一遍